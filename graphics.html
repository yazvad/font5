<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beaded Graphics — редактор</title>
  <style>
    :root{
      --bg:#000; --fg:#fff;
      --border: rgba(255,255,255,.15);
      --border-strong: rgba(255,255,255,.22);
      --panel-bg: rgba(255,255,255,.03);
      --panel-bg-2: rgba(255,255,255,.04);
      --input-bg: rgba(255,255,255,.06);
      --muted: rgba(255,255,255,.65);
      --shadow: rgba(0,0,0,.35);

      --switch-track: rgba(255,255,255,.18);
      --switch-track-on: rgba(255,255,255,.26);
      --switch-knob: rgba(255,255,255,.90);

      color-scheme: dark;
    }

    body{
      margin:0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      display:grid; place-items:center; min-height:100vh;
    }

    .wrap{ width:min(1200px, 94vw); }

    .tabs{ display:flex; gap:10px; margin-bottom:2px; }
    .tab{
      flex:1;
      text-align:center;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      color: var(--fg);
      text-decoration:none;
      font-size:14px;
    }
    .tab.active{
      border-color: var(--border-strong);
      background: var(--input-bg);
    }

    .panel{
      display:grid; gap:10px;
      padding:12px 14px;
      border:1px solid var(--border);
      border-radius:14px; margin-bottom:12px;
      background: var(--panel-bg);
      box-shadow: 0 10px 30px var(--shadow);
    }

    .top-row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

    .label{
      opacity:.9; font-size:14px; color: var(--fg);
      min-width:160px;
    }

    input[type="range"]{ width:100%; flex:1; }

    .num{
      width:44px;
      text-align:right;
      opacity:.95;
      color: var(--fg);
      flex:0 0 auto;
      margin-left:4px;
      margin-right:6px;
      font-weight:700;
    }

    .hintline{
      font-size:12px;
      color: rgba(255,255,255,.65);
      margin-top:2px;
    }

    /* Switch */
    .switch{
      position:relative;
      width:52px; height:30px;
      flex:0 0 auto;
    }
    .switch input{ display:none; }
    .slider{
      position:absolute; inset:0;
      border-radius:999px;
      background: var(--switch-track);
      border:1px solid var(--border-strong);
      transition: .2s ease;
    }
    .slider:before{
      content:"";
      position:absolute; top:50%; left:4px;
      width:22px; height:22px;
      border-radius:999px;
      transform: translateY(-50%);
      background: var(--switch-knob);
      transition: .2s ease;
      box-shadow: 0 6px 16px var(--shadow);
    }
    .switch input:checked + .slider{
      background: var(--switch-track-on);
    }
    .switch input:checked + .slider:before{
      transform: translate(22px, -50%);
    }

    .toggleBox{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      min-width:260px;
    }
    .toggleBox .left{
      display:flex; flex-direction:column; gap:2px;
      min-width:0; flex:1;
    }
    .toggleBox .title{ font-size:14px; color:var(--fg); }
    .toggleBox .hint{ font-size:12px; color:rgba(255,255,255,.65); }

    /* buttons */
    .iconBtn{
      width:46px; height:46px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      display:grid; place-items:center;
      cursor:pointer;
      flex:0 0 auto;
      color: var(--fg);
      font-weight:700;
      user-select:none;
    }
    .iconBtn img{ width:22px; height:22px; opacity:.95; display:block; }

    .btnText{
      width:auto;
      padding:0 14px;
      height:46px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--panel-bg-2);
      color: var(--fg);
      font-weight:800;
      cursor:pointer;
      letter-spacing:.02em;
    }

    .undoRedo { display:flex; gap:10px; flex:0 0 auto; }
    .iconSmall{
      width:58px; height:46px;
      border-radius:14px;
      border:1px solid var(--border);
      background:var(--panel-bg-2);
      display:grid; place-items:center;
      cursor:pointer;
      font-size:24px;
      line-height:1;
      color: var(--fg);
      user-select:none;
    }

    .stage{
      border-radius:18px; overflow:hidden;
      border:1px solid var(--border);
      background: var(--bg);
      box-shadow: 0 18px 50px var(--shadow);
      position:relative;
      touch-action: none;
      min-height:420px;
    }
    canvas{ display:block; width:100%; height:auto; }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="panel">
      <div class="tabs">
        <a class="tab" href="./index.html">Текст</a>
        <a class="tab active" href="./graphics.html">Графика</a>
      </div>

      <div class="top-row">
        <div style="flex:1; min-width:520px; display:flex; gap:12px; align-items:center;">
          <div class="label">Количество бусин (для следующей линии)</div>
          <input id="beads" type="range" min="0" max="50" value="30" />
          <div class="num"><span id="beadsVal">55</span></div>
        </div>

        <div class="undoRedo">
          <button id="undoBtn" class="iconSmall" title="Отмена (Ctrl/Cmd+Z)">⟲</button>
          <button id="redoBtn" class="iconSmall" title="Возврат (Ctrl/Cmd+Y)">⟳</button>
        </div>

        <button class="iconBtn" id="photoBtn" title="Добавить фото">
          <img src="./picture.svg" alt="Add photo">
        </button>
        <input id="photoInput" type="file" accept="image/*" hidden />

        <button id="pngBtn" class="btnText" title="Сохранить PNG (прозрачный фон)">PNG</button>
        <button id="jpgBtn" class="btnText" title="Сохранить JPG">JPG</button>

        <button class="iconBtn" id="clearBtn" title="Удалить всё с холста">
          <img src="./delete.svg" alt="Delete all">
        </button>
      </div>

      <div class="top-row">
        <div style="flex:1; min-width:520px; display:flex; gap:12px; align-items:center;">
          <div class="label">Толщина линии</div>
          <input id="strokeW" type="range" min="2" max="30" value="10" />
          <div class="num"><span id="strokeWVal">10</span></div>
        </div>

        <div class="toggleBox" style="flex:0 0 auto;">
          <div class="left">
            <div class="title">Бусины</div>
            <div class="hint"><span id="beadsModeLabel">Цветные</span></div>
          </div>
          <label class="switch" title="Цветные / Белые">
            <input id="beadsMode" type="checkbox" />
            <span class="slider"></span>
          </label>
        </div>
      </div>

      <div class="hintline">
        Рисование: зажми мышь/палец и веди. Фото: кликай по фото → двигай; тяните за угол → масштаб; колёсико → масштаб.
      </div>
    </div>

    <div class="stage">
      <canvas id="c"></canvas>
    </div>

  </div>

<script>
    const BEAD_RADIUS = 16;
    const BEAD_SIZE = BEAD_RADIUS * 2;
  
    // SVG beads (рядом с html)
    const BEAD_SVGS_COLOR = ["./blue.svg","./green.svg","./pink.svg","./purple.svg","./red.svg"];
    const BEAD_SVG_WHITE  = "./white.svg";
  
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
  
    const beadsInp = document.getElementById("beads");
    const beadsVal = document.getElementById("beadsVal");
  
    const strokeWInp = document.getElementById("strokeW");
    const strokeWVal = document.getElementById("strokeWVal");
  
    const beadsModeInp = document.getElementById("beadsMode");
    const beadsModeLabel = document.getElementById("beadsModeLabel");
  
    const photoBtn = document.getElementById("photoBtn");
    const photoInput = document.getElementById("photoInput");
  
    const pngBtn = document.getElementById("pngBtn");
    const jpgBtn = document.getElementById("jpgBtn");
  
    const clearBtn = document.getElementById("clearBtn");
  
    const undoBtn = document.getElementById("undoBtn");
    const redoBtn = document.getElementById("redoBtn");
  
    // ===== SVG cache =====
    const beadImgCache = new Map();
    function loadBeadImage(src){
      return new Promise((resolve, reject) => {
        if (beadImgCache.has(src)) return resolve(beadImgCache.get(src));
        const img = new Image();
        img.onload = () => { beadImgCache.set(src, img); resolve(img); };
        img.onerror = reject;
        img.src = src;
      });
    }
    function pickBeadSvg(rand){
      if (beadsModeInp.checked) return BEAD_SVG_WHITE;
      return BEAD_SVGS_COLOR[Math.floor(rand() * BEAD_SVGS_COLOR.length)];
    }
  
    // ===== logical canvas size (CSS px) =====
    let viewW = 1400;
    let viewH = 720;
  
    // strokes: { pts:[...], beads:number, seed:number, w:number }
    let strokes = [];
    let drawing = false;
    let current = [];
  
    // photo object
    let photo = { img:null, x:0, y:0, scale:1, rotation:0 };
  
    // interaction modes
    let mode = "none"; // draw | photo-drag | photo-resize | photo-pinch
    let photoDragOffset = { dx:0, dy:0 };
    let resizeCorner = null;
    let resizeStart = { scale:1, halfDiag:1 };
    let pinch = { active:false, startDist:0, startScale:1, startCenter:{x:0,y:0}, startPos:{x:0,y:0} };
  
    // undo/redo
    const undoStack = [];
    const redoStack = [];
    const MAX_STACK = 80;
  
    function mulberry32(seed){
      return function(){
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t>>>15), t | 1);
        t ^= t + Math.imul(t ^ (t>>>7), t | 61);
        return ((t ^ (t>>>14))>>>0) / 4294967296;
      };
    }
  
    // cursor coords in logical space (CSS px)
    function getPos(e){
      const r = canvas.getBoundingClientRect();
      const p = (e.touches && e.touches[0]) ? e.touches[0] : e;
      return {
        x: (p.clientX - r.left) * (viewW / r.width),
        y: (p.clientY - r.top)  * (viewH / r.height)
      };
    }
    function getTwoTouch(e){
      const r = canvas.getBoundingClientRect();
      const t0 = e.touches[0], t1 = e.touches[1];
      const p0 = { x:(t0.clientX - r.left) * (viewW/r.width), y:(t0.clientY - r.top) * (viewH/r.height) };
      const p1 = { x:(t1.clientX - r.left) * (viewW/r.width), y:(t1.clientY - r.top) * (viewH/r.height) };
      return { p0, p1 };
    }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
    function center(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
  
    function polylineLength(points){
      let len=0;
      for (let i=1;i<points.length;i++){
        len += Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
      }
      return len;
    }
    function pointAt(points, d){
      let acc=0;
      for (let i=1;i<points.length;i++){
        const a=points[i-1], b=points[i];
        const seg=Math.hypot(b.x-a.x, b.y-a.y);
        if (acc+seg >= d){
          const t = seg===0 ? 0 : (d-acc)/seg;
          return { x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t };
        }
        acc+=seg;
      }
      return points[points.length-1] || {x:0,y:0};
    }
  
    // ===== photo frame/handles =====
    function getPhotoRect(){
      if (!photo.img) return null;
      const iw = photo.img.width * photo.scale;
      const ih = photo.img.height * photo.scale;
      const left = photo.x - iw/2;
      const top  = photo.y - ih/2;
      const right = left + iw;
      const bottom = top + ih;
      return {
        left, top, right, bottom, iw, ih,
        tl:{x:left,y:top}, tr:{x:right,y:top}, bl:{x:left,y:bottom}, br:{x:right,y:bottom}
      };
    }
    function pointInRect(p, rect){
      return p.x >= rect.left && p.x <= rect.right && p.y >= rect.top && p.y <= rect.bottom;
    }
    function isPointOnCorner(p, c, s=12){
      return (p.x >= c.x-s && p.x <= c.x+s && p.y >= c.y-s && p.y <= c.y+s);
    }
    function cornerHit(p){
      const rect = getPhotoRect();
      if (!rect) return null;
      if (isPointOnCorner(p, rect.tl)) return "tl";
      if (isPointOnCorner(p, rect.tr)) return "tr";
      if (isPointOnCorner(p, rect.br)) return "br";
      if (isPointOnCorner(p, rect.bl)) return "bl";
      return null;
    }
  
    // ===== undo/redo state =====
    function copyState(){
      return {
        strokes: strokes.map(s => ({
          beads: s.beads, seed: s.seed, w: s.w,
          pts: s.pts.map(pt => ({x:pt.x, y:pt.y}))
        })),
        photo: (photo.img ? { src: photo.img.src, x: photo.x, y: photo.y, scale: photo.scale, rotation: photo.rotation } : null),
        ui: { beads:+beadsInp.value, strokeW:+strokeWInp.value, beadsMode:!!beadsModeInp.checked }
      };
    }
    function restoreState(st){
      strokes = st.strokes.map(s => ({
        beads: s.beads, seed: s.seed, w: s.w,
        pts: s.pts.map(pt => ({x:pt.x, y:pt.y}))
      }));
  
      if (st.ui){
        beadsInp.value = st.ui.beads ?? beadsInp.value;
        strokeWInp.value = st.ui.strokeW ?? strokeWInp.value;
        beadsModeInp.checked = !!st.ui.beadsMode;
      }
  
      beadsVal.textContent = String(beadsInp.value);
      strokeWVal.textContent = String(strokeWInp.value);
      beadsModeLabel.textContent = beadsModeInp.checked ? "Белые" : "Цветные";
  
      if (st.photo && st.photo.src){
        const img = new Image();
        img.onload = () => {
          photo.img = img;
          photo.x = st.photo.x;
          photo.y = st.photo.y;
          photo.scale = st.photo.scale;
          photo.rotation = st.photo.rotation;
          redraw();
        };
        img.src = st.photo.src;
      } else {
        photo.img = null;
        redraw();
      }
    }
    function pushState(){
      undoStack.push(copyState());
      if (undoStack.length > MAX_STACK) undoStack.shift();
      redoStack.length = 0;
      updateUndoRedo();
    }
    function updateUndoRedo(){
      undoBtn.disabled = undoStack.length === 0;
      redoBtn.disabled = redoStack.length === 0;
      undoBtn.style.opacity = undoBtn.disabled ? 0.45 : 1;
      redoBtn.style.opacity = redoBtn.disabled ? 0.45 : 1;
    }
    function undo(){
      if (undoStack.length === 0) return;
      const cur = copyState();
      redoStack.push(cur);
      const prev = undoStack.pop();
      restoreState(prev);
      updateUndoRedo();
    }
    function redo(){
      if (redoStack.length === 0) return;
      const cur = copyState();
      undoStack.push(cur);
      const next = redoStack.pop();
      restoreState(next);
      updateUndoRedo();
    }
  
    // ===== draw =====
    function drawBackground(isTransparent=false){
      ctx.clearRect(0,0,viewW,viewH);
      if (!isTransparent){
        ctx.fillStyle = "#000";
        ctx.fillRect(0,0,viewW,viewH);
      }
    }
  
    function drawPhoto(withUI=true){
      if (!photo.img) return;
  
      ctx.save();
      ctx.translate(photo.x, photo.y);
      ctx.rotate(photo.rotation);
      ctx.scale(photo.scale, photo.scale);
      ctx.drawImage(photo.img, -photo.img.width/2, -photo.img.height/2);
      ctx.restore();
  
      if (!withUI) return;
  
      const rect = getPhotoRect();
      if (!rect) return;
  
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.strokeRect(rect.left, rect.top, rect.iw, rect.ih);
      ctx.setLineDash([]);
  
      const corners = [rect.tl, rect.tr, rect.br, rect.bl];
      for (const c of corners){
        ctx.fillStyle = "#111";
        ctx.strokeStyle = "rgba(255,255,255,0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(c.x-8, c.y-8, 16, 16);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();
    }
  
    function drawStroke(points, w){
      if (points.length < 2) return;
  
      ctx.lineWidth = w;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "#fff";
  
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
  
      // quadratic smoothing by midpoints
      for (let i = 1; i < points.length - 1; i++) {
        const cx = points[i].x;
        const cy = points[i].y;
        const mx = (points[i].x + points[i + 1].x) / 2;
        const my = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(cx, cy, mx, my);
      }
  
      const last = points[points.length - 1];
      ctx.lineTo(last.x, last.y);
      ctx.stroke();
    }
  
    async function drawBeadsOnStroke(points, count, seedBase){
      const total = polylineLength(points);
      if (total <= 1 || count <= 0) return;
  
      const rand = mulberry32(seedBase);
      const pad = total * 0.06;
      const start = pad;
      const end = Math.max(start+1, total - pad);
      const span = end - start;
  
      // pick sources (random) & preload
      const sources = [];
      for (let i=0;i<count;i++) sources.push(pickBeadSvg(rand));
      const imgs = await Promise.all(sources.map(src => loadBeadImage(src).catch(()=>null)));
  
      // same seed for positions
      const rand2 = mulberry32(seedBase);
  
      for (let i=0;i<count;i++){
        const t = (count===1) ? 0.5 : i/(count-1);
        const jitter = (rand2()-0.5)*0.08;
        const d = start + span * Math.min(1, Math.max(0, t + jitter));
        const p = pointAt(points, d);
  
        const img = imgs[i];
        if (!img) continue;
  
        ctx.drawImage(img, p.x - BEAD_RADIUS, p.y - BEAD_RADIUS, BEAD_SIZE, BEAD_SIZE);
      }
    }
  
    // prevent overlapping async redraws
    let renderToken = 0;
    async function redraw(opts={transparent:false, hideUI:false}){
      const token = ++renderToken;
  
      const beadCountNext = parseInt(beadsInp.value, 10);
      beadsVal.textContent = String(beadCountNext);
  
      const wNow = parseInt(strokeWInp.value, 10);
      strokeWVal.textContent = String(wNow);
  
      beadsModeLabel.textContent = beadsModeInp.checked ? "Белые" : "Цветные";
  
      drawBackground(!!opts.transparent);
  
      drawPhoto(!opts.hideUI);
  
      for (let i=0;i<strokes.length;i++){
        if (token !== renderToken) return;
        const s = strokes[i];
        drawStroke(s.pts, s.w);
        await drawBeadsOnStroke(s.pts, s.beads, s.seed);
      }
  
      if (drawing && current.length>1){
        if (token !== renderToken) return;
        drawStroke(current, wNow);
        await drawBeadsOnStroke(current, beadCountNext, 999999);
      }
    }
  
    // ===== interactions =====
    function startPointer(e){
      // pinch zoom photo
      if (e.touches && e.touches.length === 2 && photo.img){
        e.preventDefault();
        const {p0,p1} = getTwoTouch(e);
        pinch.active = true;
        pinch.startDist = dist(p0,p1);
        pinch.startScale = photo.scale;
        pinch.startCenter = center(p0,p1);
        pinch.startPos = { x: photo.x, y: photo.y };
        mode = "photo-pinch";
        pushState();
        return;
      }
  
      const p = getPos(e);
  
      // resize corner
      const c = cornerHit(p);
      if (c){
        e.preventDefault();
        mode = "photo-resize";
        resizeCorner = c;
        const rect = getPhotoRect();
        resizeStart.scale = photo.scale;
        resizeStart.halfDiag = rect ? Math.hypot(rect.iw/2, rect.ih/2) : 1;
        pushState();
        return;
      }
  
      // drag photo
      if (photo.img){
        const rect = getPhotoRect();
        if (rect && pointInRect(p, rect)){
          e.preventDefault();
          mode = "photo-drag";
          photoDragOffset.dx = p.x - photo.x;
          photoDragOffset.dy = p.y - photo.y;
          pushState();
          return;
        }
      }
  
      // draw
      e.preventDefault();
      mode = "draw";
      drawing = true;
      current = [p];
      redraw();
    }
  
    function movePointer(e){
      if (mode === "photo-pinch" && e.touches && e.touches.length === 2 && photo.img){
        e.preventDefault();
        const {p0,p1} = getTwoTouch(e);
        const d = dist(p0,p1);
        const c = center(p0,p1);
  
        const k = (pinch.startDist === 0) ? 1 : (d / pinch.startDist);
        photo.scale = Math.max(0.05, Math.min(10, pinch.startScale * k));
  
        const dx = c.x - pinch.startCenter.x;
        const dy = c.y - pinch.startCenter.y;
        photo.x = pinch.startPos.x + dx;
        photo.y = pinch.startPos.y + dy;
  
        redraw();
        return;
      }
  
      if (mode === "photo-drag"){
        e.preventDefault();
        const p = getPos(e);
        photo.x = p.x - photoDragOffset.dx;
        photo.y = p.y - photoDragOffset.dy;
        redraw();
        return;
      }
  
      if (mode === "photo-resize"){
        e.preventDefault();
        const p = getPos(e);
        const dx = Math.abs(p.x - photo.x);
        const dy = Math.abs(p.y - photo.y);
        const halfDiagNew = Math.hypot(dx, dy);
        const k = (resizeStart.halfDiag === 0) ? 1 : (halfDiagNew / resizeStart.halfDiag);
        photo.scale = Math.max(0.05, Math.min(10, resizeStart.scale * k));
        redraw();
        return;
      }
  
      if (mode === "draw"){
        e.preventDefault();
        const p = getPos(e);
        const last = current[current.length-1];
  
        const SMOOTH_STEP = 3;
        if (!last || Math.hypot(p.x-last.x, p.y-last.y) > SMOOTH_STEP){
          current.push(p);
          redraw();
        }
      }
    }
  
    function endPointer(){
      if (mode === "draw" && drawing){
        drawing = false;
        if (current.length > 1){
          const pts = current.map(pt => ({x:pt.x, y:pt.y}));
          const beadsNow = parseInt(beadsInp.value, 10);
          const wNow = parseInt(strokeWInp.value, 10);
          const seed = 12345 + strokes.length * 999;
          strokes.push({ pts, beads: beadsNow, seed, w: wNow });
          pushState();
        }
        current = [];
      }
      pinch.active = false;
      mode = "none";
      resizeCorner = null;
      redraw();
    }
  
    // wheel zoom over photo
    canvas.addEventListener("wheel", (e) => {
      if (!photo.img) return;
      const p = getPos(e);
      const rect = getPhotoRect();
      if (!rect || !pointInRect(p, rect)) return;
  
      e.preventDefault();
  
      const delta = -e.deltaY;
      const factor = Math.exp(delta * 0.0018);
  
      const prev = photo.scale;
      const next = Math.max(0.05, Math.min(10, prev * factor));
      const k = next / prev;
  
      photo.x = p.x - (p.x - photo.x) * k;
      photo.y = p.y - (p.y - photo.y) * k;
      photo.scale = next;
  
      pushState();
      redraw();
    }, { passive:false });
  
    canvas.addEventListener("mousedown", startPointer);
    window.addEventListener("mousemove", movePointer);
    window.addEventListener("mouseup", endPointer);
  
    canvas.addEventListener("touchstart", startPointer, { passive:false });
    window.addEventListener("touchmove", movePointer, { passive:false });
    window.addEventListener("touchend", endPointer, { passive:false });
    window.addEventListener("touchcancel", endPointer, { passive:false });
  
    // ===== UI =====
    beadsInp.addEventListener("input", () => redraw());
    strokeWInp.addEventListener("input", () => redraw());
    beadsModeInp.addEventListener("change", () => redraw());
  
    // photo upload
    photoBtn.addEventListener("click", () => {
      photoInput.value = "";
      photoInput.click();
    });
  
    photoInput.addEventListener("change", () => {
      const file = photoInput.files && photoInput.files[0];
      if (!file) return;
  
      const url = URL.createObjectURL(file);
      const img = new Image();
  
      img.onload = () => {
        photo.img = img;
        photo.x = viewW / 2;
        photo.y = viewH / 2;
  
        const target = Math.min(viewW, viewH) * 0.6;
        const s = target / Math.max(img.width, img.height);
        photo.scale = Math.max(0.05, Math.min(10, s));
        photo.rotation = 0;
  
        URL.revokeObjectURL(url);
        pushState();
        redraw();
      };
  
      img.onerror = () => {
        URL.revokeObjectURL(url);
        alert("Не удалось загрузить изображение. Попробуй другой файл.");
      };
  
      img.src = url;
    });
  
    // save
    function downloadDataUrl(dataUrl, filename){
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  
    async function savePNG(){
      await redraw({ transparent:true, hideUI:true });
      const dataUrl = canvas.toDataURL("image/png");
      downloadDataUrl(dataUrl, "beaded-graphics.png");
      redraw();
    }
  
    async function saveJPG(){
      await redraw({ transparent:false, hideUI:true });
      const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
      downloadDataUrl(dataUrl, "beaded-graphics.jpg");
      redraw();
    }
  
    pngBtn.addEventListener("click", savePNG);
    jpgBtn.addEventListener("click", saveJPG);
  
    // clear
    function clearAll(){
      pushState();
      strokes = [];
      drawing = false;
      current = [];
      photo.img = null;
      redraw();
    }
    clearBtn.addEventListener("click", clearAll);
  
    // undo/redo buttons + hotkeys
    undoBtn.addEventListener("click", undo);
    redoBtn.addEventListener("click", redo);
  
    window.addEventListener("keydown", (e) => {
      const isMac = navigator.platform.toUpperCase().includes("MAC");
      const mod = isMac ? e.metaKey : e.ctrlKey;
      if (!mod) return;
  
      const key = e.key.toLowerCase();
      if (key === "z" && !e.shiftKey){
        e.preventDefault(); undo();
      } else if (key === "y" || (key === "z" && e.shiftKey)){
        e.preventDefault(); redo();
      }
    });
  
    // retina-safe resize
    function resizeCanvas(){
      const stage = canvas.parentElement;
      const r = stage.getBoundingClientRect();
  
      viewW = Math.max(600, Math.floor(r.width));
      viewH = Math.max(360, Math.floor(r.width * (720/1400)));
  
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = Math.floor(viewW * dpr);
      canvas.height = Math.floor(viewH * dpr);
      canvas.style.width  = viewW + "px";
      canvas.style.height = viewH + "px";
  
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  
      if (photo.img && (photo.x === 0 && photo.y === 0)){
        photo.x = viewW/2;
        photo.y = viewH/2;
      }
  
      redraw();
    }
    window.addEventListener("resize", resizeCanvas);
  
    // init
    beadsVal.textContent = String(beadsInp.value);
    strokeWVal.textContent = String(strokeWInp.value);
    beadsModeLabel.textContent = beadsModeInp.checked ? "Белые" : "Цветные";
  
    updateUndoRedo();
    resizeCanvas();
    pushState();
    redraw();
</script>  
  
</body>
</html>
